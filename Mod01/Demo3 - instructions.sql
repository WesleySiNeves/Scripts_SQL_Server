-- Module 1 - Demo 2 - File 3

-- Step 1 - From the solution, open and execute the query Demo2i - Create hanging transaction.sql against MIA-SQL

-- Step 2 - From the solution, open and execute the query Demo2ii - Start blocked transaction.sql against MIA-SQL
-- note the value of select_session_id in the results pane

-- Step 3 - Examine sys.dm_os_waiting_tasks by running the following query.
-- Note that the session_id of one row returned by this query should match the session id you noted in step 2
-- Note that the wait type is LCK_M_S

/*master : https://docs.microsoft.com/en-us/previous-versions/sql/sql-server-2008-r2/ms186396(v=sql.105)*/

/*master : LCK_M_S  : Ocorre quando uma tarefa quer adiquirir um bloqueio compartilhado (select) entretando o resurso já te, 
um bloqueio exclusivo */
SELECT wait.session_id AS [sessão bloqueada],
	   CONVERT(TIME,DATEADD (ms, wait.wait_duration_ms, 0)) AS Segundos,
       wait.wait_type,
       wait.resource_address,
       wait.blocking_session_id AS [Sessao Bloqueando],
       wait.resource_description
FROM sys.dm_os_waiting_tasks wait
WHERE wait.session_id IN (57,55);
/* ==================================================================
--Autor :Wesley Neves
--Observação: Etapa 4 - Modifique a consulta a seguir para adicionar o 
ID da sessão que você anotou na etapa 2 e, em seguida, execute-o
- para examinar sys.dm_exec_session_wait_stats.
- Observe que o LCK_M_S ainda não aparece porque a sessão ainda está esperando
 
-- ==================================================================
*/
SELECT * FROM sys.dm_exec_session_wait_stats WHERE session_id IN(90,55);

-- Step 5 - return to the query window where Demo2i - Create hanging transaction.sql is running.
-- Uncomment and execute the ROLLBACK command at the end of the file.

-- Step 6 - re-run the query from step 4.
-- Note that this time, the LCK_M_S wait is included in the results because the session has finished waiting
SELECT wa.session_id,
       wa.wait_type,
	    wa.wait_time_ms,
	   CONVERT(TIME,DATEADD (ms,wa.wait_time_ms, 0)) AS Segundos,
       wa.waiting_tasks_count,
       wa.max_wait_time_ms,
       wa.signal_wait_time_ms FROM sys.dm_exec_session_wait_stats wa WHERE session_id = 90;


-- Step 7 - WRITELOG and PAGELATCH_* waits
-- This demonstration causes PAGELATCH and WRITELOG waits by having 50 processes insert into 
-- a table with narrow rows (dbo.insertTarget) and an identity column as the clustered primary key.
-- First, clear the target table and wait stats


TRUNCATE TABLE TSQL.dbo.insertTarget;

DBCC SQLPERF('sys.dm_os_wait_stats',clear);

/* ==================================================================
--Observação: WRITELOG
Esse tipo de espera é quando uma thread  está aguardando que um bloco de log seja gravado no disco 
por uma E /S assíncrona. Um bloco de log é gravado no disco quando:
Uma transação é confirmada (a menos que seja configurada (delayed durable in SQL Server 2014 + OLTP in memory)
O bloco de log atinge seu tamanho máximo de 60Kb

A SP  sp_flush_log proc for executada (in SQL Server 2014  +)

alternativas para diminuir(reduzir  as esperas e os tempos de espera de WRITELOG)

Atualize para 2012 ou superior para aumentar as gravações de logs max-outstanding de 32 para 112
Coloque o log de transações na parte mais rápida do subsistema de E / S
Considere a implementação   delayed durability (in 2014+) or in-memory OLTP/Hekaton

https://www.sqlskills.com/help/waits/writelog/


 
-- ==================================================================
*/
-- Step 8 - Demonstrate that the writelog and pagelatch wait types are zero (or near zero)
SELECT * FROM sys.dm_os_wait_stats WHERE wait_type = 'WRITELOG'
UNION ALL
SELECT * FROM sys.dm_os_wait_stats WHERE wait_type like 'PAGELATCH%';

-- Step 9 - Start Resource Monitor (Click Start, then type "Resource Monitor" and press enter). 
-- On the Disk tab, notice that the Disk Queue graph for the D: drive (where the database files are located) is near zero.

-- Step 10 - start the load by right-clicking D:\Demofiles\Mod01\start_load_1.ps1 and click "Run with PowerShell" in Windows Explorer
-- then return to this window and follow the instructions below.
-- It may take a few seconds for activity from the load to appear in the queries
-- The load generated by the script will last for approximately 5 minutes. If you need to restart the load, start step 10 again.

-- Step 11 - Demonstrate that the writelog and pagelatch wait types are climbing
-- run this query several times over the course of a minute or so whilst the load is running.
SELECT * FROM sys.dm_os_wait_stats WHERE wait_type = 'WRITELOG'
UNION ALL
SELECT * FROM sys.dm_os_wait_stats WHERE wait_type like 'PAGELATCH%';

-- Step 12 - return to Resource Monitor and observe that the disk queue for the D: drive is elevated.
